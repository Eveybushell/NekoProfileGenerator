"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var index_exports = {};
__export(index_exports, {
  Client: () => Client,
  default: () => index_default,
  fetchRandom: () => fetchRandom
});
module.exports = __toCommonJS(index_exports);
const IMAGE_CATEGORIES = ["kitsune", "neko", "husbando", "waifu"];
const GIF_CATEGORIES = [
  "angry",
  "baka",
  "bite",
  "blush",
  "bonk",
  "bored",
  "cry",
  "cuddle",
  "dance",
  "facepalm",
  "feed",
  "handhold",
  "handshake",
  "happy",
  "highfive",
  "hug",
  "kick",
  "kiss",
  "laugh",
  "lurk",
  "nod",
  "nom",
  "nope",
  "pat",
  "peck",
  "poke",
  "pout",
  "punch",
  "run",
  "shoot",
  "shrug",
  "slap",
  "sleep",
  "smile",
  "smug",
  "stare",
  "tableflip",
  "think",
  "thumbsup",
  "tickle",
  "wave",
  "wink",
  "yawn",
  "yeet"
];
async function fetchRandom(category) {
  return new Client().fetch(category, 1);
}
class Client {
  #ratelimitData = null;
  #clientOptions;
  constructor(clientOptions) {
    this.#clientOptions = {
      ratelimitHandleMode: "sleep",
      ...clientOptions
    };
  }
  /**
   * Fetch and download a random file with its metadata (if available).
   * For more advanced options, you should use the `Client.fetch()` method and
   * fetch the file by yourself.
   *
   * Refer to the documentation for more details: https://docs.nekos.best/api/endpoints.html#get-categoryfilenameformat
   *
   * @param category The category to download from.
   */
  async fetchFile(category = null) {
    const fileDetails = (await this.fetch(category, 1)).results[0];
    const file = await fetchPath(void 0, fileDetails.url);
    return {
      ...fileDetails,
      data: Buffer.from(await file.arrayBuffer())
    };
  }
  /**
   * Fetch multiple assets with their metadata (if available).
   *
   * Refer to the documentation for more details: https://docs.nekos.best/api/endpoints.html#get-categoryamountx
   *
   * @param category Category of assets. Set to `null` to pick a random category.
   * @param amount The amount of assets. Refer to the documentation for the limits.
   */
  async fetch(category = null, amount) {
    if (!category) {
      category = pickRandomCategory();
    } else {
      validateCategory(category);
    }
    if (!Number.isSafeInteger(amount)) {
      throw new TypeError(
        `Expected a safe integer for amount. Got "${amount}".`
      );
    }
    return fetchJson(`${category}?amount=${amount}`);
  }
  /**
   * Search for assets.
   *
   * Refer to the documentation for more details: https://docs.nekos.best/api/endpoints.html#get-searchqueryxtypexcategoryxamountx
   *
   * @param query Search query.
   * @param category Category of assets. Set to `null` to pick a random category.
   * @param amount The amount of assets. Refer to the documentation for the limits.
   */
  async search(query, category = null, amount = 1) {
    if (this.#ratelimitData != null) {
      await handleRatelimit(
        this.#clientOptions.ratelimitHandleMode,
        this.#ratelimitData
      );
    }
    if (!category) {
      category = pickRandomCategory();
    } else {
      validateCategory(category);
    }
    if (!Number.isSafeInteger(amount)) {
      throw new TypeError(
        `Expected a safe integer for amount. Got "${amount}".`
      );
    }
    const type = 2 - +IMAGE_CATEGORIES.includes(category);
    const response = await fetchPath(
      `search?query=${encodeURIComponent(query)}&type=${type}&category=${category}&amount=${amount}`
    );
    const remaining = response.headers.get("x-rate-limit-remaining");
    const resetsIn = response.headers.get("x-rate-limit-reset");
    if (remaining != null && resetsIn != null) {
      this.#ratelimitData = {
        resetsIn: Date.parse(resetsIn),
        remaining: Number(remaining)
      };
    }
    return await response.json();
  }
}
async function fetchPath(path, fullUrl = null) {
  const url = fullUrl || `https://nekos.best/api/v2/${path}`;
  const response = await fetch(url, {
    headers: { "User-Agent": "nekos-best.js / 6.5.0" },
    redirect: "follow"
  });
  if (!response.ok) {
    const text = await response.text();
    throw new Error(
      `Failed to fetch url "${url}" (status code ${response.status}): ${text}`
    );
  }
  return response;
}
var index_default = Client;
async function fetchJson(path) {
  return await (await fetchPath(path)).json();
}
function validateCategory(category) {
  if (!(IMAGE_CATEGORIES.includes(category) || GIF_CATEGORIES.includes(category))) {
    throw new TypeError(
      `"${category}" is not a valid category. Available categories: ${IMAGE_CATEGORIES.join(", ")}, ${GIF_CATEGORIES.join(", ")}`
    );
  }
}
function pickRandomCategory() {
  const idx = Math.random() * (GIF_CATEGORIES.length + IMAGE_CATEGORIES.length) | 0;
  if (idx < IMAGE_CATEGORIES.length) {
    return IMAGE_CATEGORIES[idx];
  }
  return GIF_CATEGORIES[idx - IMAGE_CATEGORIES.length];
}
async function handleRatelimit(mode, data) {
  const now = Date.now();
  if (data.remaining <= 0 && data.resetsIn > now) {
    switch (mode) {
      case "sleep":
        await new Promise(
          (resolve) => setTimeout(resolve, data.resetsIn - now)
        );
        return;
      case "throw":
        throw Error("You are being ratelimited");
    }
  }
  --data.remaining;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Client,
  fetchRandom
});
